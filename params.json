{"name":"Ruby-validation","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"ruby validation library","google":"UA-18882040-3","body":"# Frank\r\n\r\na ruby validation library\r\n\r\n## Disclaimer\r\n\r\nThis is a work in progress. Documented features are not yet implemented, this documentation is to describe what will be implemented.\r\n\r\n## Installing\r\n\r\n```shell\r\ngem install frank\r\n```\r\n\r\n## Quick start\r\n\r\nLet's say we have the following classes:\r\n\r\n```ruby\r\nAddress = Struct.new(:recipient, :street, :street2, :city, :state, :zip)\r\nAuthor  = Struct.new(:email, :first_name, :last_name, :address)\r\n```\r\n\r\nTo be able to validate them, we need to describe validation rules for those classes:\r\n\r\n```ruby\r\nFrank.valid(Address) do\r\n  attribute(:recipient) do\r\n    should_not be_empty\r\n    should be_kind_of(String)\r\n    should have_at_least(3).characters\r\n    should have_at_most(255).characters\r\n    should have_only_letters\r\n  end\r\n\r\n  attribute(:street) do\r\n    should_not be_empty\r\n    should be_kind_of(String)\r\n    should have_at_least(3).characters\r\n    should have_at_most(255).characters\r\n    should have_only_letters_and_numbers # custom validation constraint\r\n  end\r\n\r\n  attribute(:street2) do # optional\r\n    should be_kind_of(String)\r\n    should have_at_least(3).characters\r\n    should have_at_most(255).characters\r\n    should have_only_letters_and_numbers\r\n  end\r\n\r\n  attribute(:city) do\r\n    should_not be_empty\r\n    should be_kind_of(String)\r\n    should have_at_least(3).characters\r\n    should have_at_most(255).characters\r\n    should have_only_letters # custom validation constraint\r\n  end\r\n\r\n  attribute(:state) do\r\n    should_not be_empty\r\n    should be_kind_of(String)\r\n    should have_at_exactly(2).characters\r\n    should have_only_uppercase_letters # custom validation constraint\r\n  end\r\n\r\n  attribute(:zip) do\r\n    should_not be_empty\r\n    should be_kind_of(String)\r\n    should have_exactly_most(5).characters\r\n    should have_only_numbers # custom validation constraint\r\n  end\r\nend\r\n\r\nFrank.valid(Author) do\r\n  should have_unique(:email) # custom validation constraint\r\n  attribute(:email).should_not be_empty\r\n  attribute(:email).should be_an_email # custom validation constraint\r\n  # or\r\n  attribute(:email) do\r\n    should_not be_empty\r\n    should be_unique # custom validation constraint\r\n    should be_an_email # custom validation constraint\r\n  end\r\n\r\n  attribute(:first_name) do\r\n    should_not be_empty\r\n    should be_kind_of(String)\r\n    should have_at_least(1).character\r\n    should have_at_most(32).characters\r\n    # or\r\n    # attribute(:length) do\r\n    #   should be >= 4\r\n    #   should be <= 5\r\n    # end\r\n    # has different validation semantics\r\n  end\r\n\r\n  attribute(:last_name) do\r\n    should_not be_empty\r\n    should be_kind_of(String)\r\n    should have_at_least(1).character\r\n    should have_at_most(32).characters\r\n  end\r\n\r\n  attribute(:address).should be_valid\r\n  # or\r\n  attribute(:address).should be_valid(Address)\r\nend\r\n```\r\n\r\nNow we can validate any instance of address or author:\r\n\r\n```ruby\r\naddress = Address.new(\"John Smith\", \"123 Sesame Street\", nil, \"Neverland\", \"NY\", \"94608\")\r\nauthor  = Author.new(\"username@example.com\", \"John\", \"Smith\", address)\r\n\r\nvalidation_result = Frank.validate(author)\r\nvalidation_result.valid?.should == true\r\n```\r\n\r\nThe validations above seem a little too verbose, but we can simplify them:\r\n\r\n```ruby\r\nFrank.valid(\"medium string entry\") do\r\n  should be_kind_of(String)\r\n  should have_at_least(3).characters\r\n  should have_at_most(255).characters\r\nend\r\n\r\nFrank.valid(\"required string entry\") do\r\n  should_not be_empty\r\n  should be_valid(\"medium string entry\")\r\nend\r\n\r\nFrank.valid(Address) do\r\n  attribute(:recipient) do\r\n    should be_valid(\"required string entry\")\r\n    should have_only_letters\r\n  end\r\n\r\n  attribute(:street) do\r\n    should be_valid(\"required string entry\")\r\n    should have_only_letters_and_numbers # custom validation constraint\r\n  end\r\n\r\n  attribute(:street2) do # street2 is optional\r\n    should be_valid(\"medium string entry\")\r\n    should have_only_letters_and_numbers\r\n  end\r\n\r\n  attribute(:city) do\r\n    should be_valid(\"required string entry\")\r\n    should have_only_letters # custom validation constraint\r\n  end\r\n\r\n  attribute(:state) do\r\n    should_not be_empty\r\n    should be_kind_of(String)\r\n    should have_at_exactly(2).characters\r\n    should have_only_uppercase_letters # custom validation constraint\r\n  end\r\n\r\n  attribute(:zip) do\r\n    should_not be_empty\r\n    should be_kind_of(String)\r\n    should have_exactly_most(5).characters\r\n    should have_only_numbers # custom validation constraint\r\n  end\r\nend\r\n\r\nFrank.valid(\"name\") do\r\n  should_not be_empty\r\n  should be_kind_of(String)\r\n  should have_at_least(1).character\r\n  should have_at_most(32).characters\r\nend\r\n\r\nFrank.valid(Author) do\r\n  should have_unique(:email) # custom validation constraint\r\n  attribute(:email).should_not be_empty\r\n  attribute(:email).should be_an_email # custom validation constraint\r\n  # or\r\n  attribute(:email) do\r\n    should_not be_empty\r\n    should be_unique # custom validation constraint\r\n    should be_an_email # custom validation constraint\r\n  end\r\n\r\n  attribute(:first_name).should be_valid(\"name\")\r\n\r\n  attribute(:last_name).should be_valid(\"name\")\r\n\r\n  attribute(:address).should be_valid\r\nend\r\n```\r\n\r\nThe above is nice when you have objects that you want to validate. Sometimes, however, all we have are Array and Hash structures. Frank supports those too:\r\n\r\n```ruby\r\nFrank.valid(\"required string\") do\r\n  should_not be_empty\r\n  should be_kind_of(String)\r\nend\r\n\r\nFrank.valid(\"create author request parameters\") do\r\n  should have_properties(\"name\", \"address\")\r\n\r\n  property(\"name\") do\r\n    should be_valid(\"required string entry\")\r\n    should have_only_letters_and_numbers\r\n  end\r\n\r\n  property(\"address\") do\r\n    should have_properties(\"recipient\", \"street\", \"street2\", \"city\", \"state\", \"zip\")\r\n\r\n    property(\"recipient\") do\r\n      should be_valid(\"required string entry\")\r\n      should have_only_letters\r\n    end\r\n\r\n    property(\"street\") do\r\n      should be_valid(\"required string entry\")\r\n      should have_only_letters_and_numbers\r\n    end\r\n\r\n    property(\"street2\") do\r\n      should be_valid(\"medium string entry\")\r\n      should have_only_letters_and_numbers\r\n    end\r\n\r\n    property(\"city\") do\r\n      should be_valid(\"required string entry\")\r\n      should have_only_letters_and_numbers\r\n    end\r\n\r\n    property(\"state\") do\r\n      should be_valid(\"required string\")\r\n      should have_at_exactly(2).characters\r\n      should have_only_uppercase_letters # custom validation constraint\r\n    end\r\n\r\n    property(\"zip\") do\r\n      should be_valid(\"required string\")\r\n      should have_exactly_most(5).characters\r\n      should have_at_most(5).characters\r\n    end\r\n  end\r\nend\r\n\r\nparams = {\r\n  \"name\" => \"John Smith\",\r\n  \"address\" => {\r\n    \"recipient\" => \"John Smith\",\r\n    \"street\" => \"123 Sesame Street\",\r\n    \"street2\" => nil,\r\n    \"city\" => \"Neverland\",\r\n    \"state\" => \"NY\",\r\n    \"zip\" => \"94608\"\r\n  }\r\n}\r\n\r\nvalidation_result = Frank.validate(params, :as => \"create author request parameters\")\r\n\r\nvalidation_result.valid?.should == true\r\n```\r\n\r\nAnd arrays:\r\n\r\n```ruby\r\nFrank.valid(\"email addresses\") do\r\n  should have_at_least(3).emails\r\n\r\n  children do\r\n    should_not be_empty\r\n    should be_an_email\r\n  end\r\nend\r\n```\r\n\r\n## Built-in constraints\r\n\r\nFrank ships with some built-in constraints. Most of them are inspired by RSpec's matchers.\r\n\r\n* be_false     - validate falsiness of a value.\r\n* be_true      - validate truthyness of a value.\r\n* be_valid(type) - validate an object as a valid type (defaults to its class).\r\n\r\n"}